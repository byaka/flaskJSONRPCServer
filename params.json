{
  "name": "flaskJSONRPCServer",
  "tagline": "A Python (2) \"JSON-RPC over http\" server with hot-reloading and many more",
  "body": "[![PyPI version](https://img.shields.io/pypi/v/flaskJSONRPCServer.svg)](https://pypi.python.org/pypi/flaskJSONRPCServer)\r\n[![PyPI downloads](https://img.shields.io/pypi/dm/flaskJSONRPCServer.svg)](https://pypi.python.org/pypi/flaskJSONRPCServer)\r\n[![License](https://img.shields.io/pypi/l/flaskJSONRPCServer.svg)](http://www.apache.org/licenses/LICENSE-2.0.html)\r\n\r\n\r\n# flaskJSONRPCServer\r\nThis library is an extended implementation of server for JSON-RPC protocol. It supports only json-rpc 2.0 specification for now, which includes batch submission, keyword arguments, notifications, etc.\r\n\r\n### Comments, bug reports\r\nflaskJSONRPCServer resides on **github**. You can file issues or pull requests [there](https://github.com/byaka/flaskJSONRPCServer/issues).\r\n\r\n### Requirements\r\n - **Python2.6** or **Python2.7**\r\n - **Flask** >= 0.10 (not tested with older version)\r\n - **Gevent** >= 1.0 (optionally, but recommended)\r\n\r\n####[How to install](#install)\r\n####[Documentation](https://byaka.github.io/flaskJSONRPCServer-docs/)\r\n####[About Gevent and async](#gevent-and-async)\r\n####[About hot-reloading](#hot-reloading)\r\n####[Simple example](#examples)\r\n####[Licensing](#license)\r\n\r\n### Pros\r\n - Lib ready for **production**, we use it in some products\r\n - Lib tested over **\"highload\"** (over 60 connections per second, 24/7 and it's not simulation) with **Gevent** enabled and no stability issues or memory leak (this is why i'm wrote this library)\r\n - Auto **CORS**\r\n - Simple switching to **Gevent** as backend\r\n - Auto fallback to **JSONP** on GET requests (for old browsers, that don't support CORS like **IE**<10)\r\n - Dispatchers can simply get info about connection (**IP**, **Cookies**, **Headers**)\r\n - Dispatchers can simply set **Cookies**, change output **Headers**, change output format for **JSONP** requests\r\n - Lib fully support **Notification** requests (see _example/notify.py_)\r\n - Lib supports **restarting** server (see _example/restart.py_)\r\n - Lib supports **hot-reloading** of API (see _example/hotReload1.py_, _example/hotReload2.py_)\r\n - Lib supports **multiple servers** in one app (see _example/multiple.py_)\r\n - Lib supports **merging** with another WSGI app on the same IP:PORT (see _example/mergeFlaskApp.py_)\r\n - Lib supports different **execution-backends**, for example multiprocessing (see _example/parallelExecuting.py_)\r\n - Lib supports **locking** (you can lock all server or specific dispatchers)\r\n - Lib supports different **serializing-backends** so you can implement any protocol, not only JSON\r\n - Lib supports **individual settings** for different dispatchers. For example one of them can be processed with parallel (multiprocess) backend, other with standard processing\r\n - Lib collects self **speed-stats**\r\n\r\n### Cons\r\n - Not fully **documentated**. For now only examples in package and [API documentation](https://byaka.github.io/flaskJSONRPCServer-docs/).\r\n - Lib not has **decorators**, so it not a \"Flask-way\" (this can be simply added, but i not use decorators, sorry)\r\n\r\n### Install\r\n```pip install flaskJSONRPCServer```\r\n\r\n### Gevent and async\r\nSome serverâ€™s methods (like JSON processing or compression) not supported greenlets switching while processing. It can be big performance problem on highload. I start to implement functionality to solve this. Please see [experimental package](https://github.com/byaka/flaskJSONRPCServer/blob/with_parallel_executing/flaskJSONRPCServer/experimental/README.md).\r\n\r\n### Hot-reloading\r\nYou can overload source of server without stopping.\r\n```python\r\nserver.reload(data, clearOld=False)\r\n```\r\nFlag ``<clearOld>`` will remove all earlier existing dispatchers.\r\n\r\nThis operation safe, if something goes wrong, lib restore previous source. While reloading, server stop processing requests, but not reject them. Server handle all requests, and when reloading completed, all handled requests will be processed. It also wait for completing processing requests before start reloading and you can pass ``<timeout>`` for this waiting. Also you can pass ``<processingDispatcherCountMax>`` and server will not wait for given number of processed requests.\r\n\r\nWhen reloading, you can change source, merge new variables with old and many more.\r\n\r\n```python\r\ndata=[\r\n   {'dispatcher':'testForReload1', 'scriptPath':server._getScriptPath(True), 'isInstance':False,'overload':[{'globalVar1':globalVar1}, callbackForManualOverload], 'path':'/api'}\r\n]\r\n```\r\n\r\nFor now overloading supports for any dispatcher or several dispatchers separately (you can fully change all dispatcher's settings and of course source and variables).\r\n\r\nWhen you reload dispatcher and give path for file (of course it can be same file as \"main\"), this file imported. Then lib overloaded variables and attributes you give and replace old dispatcher with new from this module. If you give one path for several dispatchers, they all work in one imported file (in this case file will import one time only, not for every dispatcher).\r\n\r\nIf you need to overload some objects, that not dispatchers but used in them, you simply can do this with callback.\r\n\r\n```python\r\ndef callbackForManualOverload(server, module, dispatcher):\r\n   # overload globals also\r\n   for k in dir(module):\r\n      globals()[k]=getattr(module, k)\r\n```\r\nThis code overload all global variables and replace them with variables from just imported file. In future i add simple method for reloading all source of server.\r\n\r\n### Examples\r\nSimple server. More examples you can find in directory _example/_\r\n\r\n```python\r\nimport sys, time, random\r\nfrom flaskJSONRPCServer import flaskJSONRPCServer\r\n\r\nclass mySharedMethods:\r\n   def random(self):\r\n      # Sipmly return random value (0..mult)\r\n      return int(random.random()*65536)\r\n\r\nclass mySharedMethods2:\r\n   def random(self):\r\n      # Sipmly return random value (0..mult)\r\n      return round(random.random()*1, 1)\r\n\r\ndef echo(data='Hello world!'):\r\n   # Simply echo\r\n   return data\r\necho._alias='helloworld' #setting alias for method\r\n\r\ndef myip(_connection=None):\r\n   # Return client's IP\r\n   return 'Hello, %s!'%(_connection.ip)\r\n\r\ndef setcookie(_connection=None):\r\n   # Set cookie to client\r\n   print _connection.cookies\r\n   _connection.cookiesOut.append({'name':'myTestCookie', 'value':'Your IP is %s'%_connection.ip, 'domain':'byaka.name'})\r\n   return 'Setted'\r\n\r\ndef stats(_connection=None):\r\n   #return server's speed stats\r\n   return _connection.server.stats(inMS=True) #inMS=True return stats in milliseconds\r\n\r\ndef big(_connection=None):\r\n   _connection.allowCompress=True #allow compression for this method only\r\n   s=\"\"\"\r\n... large data here ...\r\n   \"\"\"\r\n   return s\r\n\r\nbig._alias=['bigdata', 'compressed'] #setting alias for method\r\n\r\nif __name__=='__main__':\r\n   print 'Running api..'\r\n   # Creating instance of server\r\n   #    <blocking>         switch server to sync mode when <gevent> is False\r\n   #    <cors>             switch auto CORS support\r\n   #    <gevent>           switch to using Gevent as backend\r\n   #    <debug>            switch to logging connection's info from Flask\r\n   #    <log>              switch to logging debug info from flaskJSONRPCServer\r\n   #    <fallback>         switch auto fallback to JSONP on GET requests\r\n   #    <allowCompress>    switch auto compression\r\n   #    <compressMinSize>  set min limit for compression\r\n   #    <tweakDescriptors> set descriptor's limit for server\r\n   #    <jsonBackend>      set JSON backend. Auto fallback to native when problems\r\n   #    <notifBackend>     set backend for Notify-requests\r\n   server=flaskJSONRPCServer((\"0.0.0.0\", 7001), blocking=False, cors=True, gevent=True, debug=False, log=False, fallback=True, allowCompress=False, jsonBackend='simplejson', notifBackend='simple', tweakDescriptors=[1000, 1000])\r\n   # Register dispatcher for all methods of instance\r\n   server.registerInstance(mySharedMethods(), path='/api')\r\n   # same name, but another path\r\n   server.registerInstance(mySharedMethods2(), path='/api2')\r\n   # Register dispatchers for single functions\r\n   server.registerFunction(setcookie, path='/api')\r\n   server.registerFunction(echo, path='/api')\r\n   server.registerFunction(myip, path='/api')\r\n   server.registerFunction(big, path='/api')\r\n   server.registerFunction(stats, path='/api')\r\n   # Run server\r\n   server.serveForever()\r\n   # Now you can access this api by path http://127.0.0.1:7001/api for JSON-RPC requests\r\n   # Or by path http://127.0.0.1:7001/api/<method>?jsonp=<callback>&(params) for JSONP requests\r\n   #    For example by http://127.0.0.1:7001/api/echo?data=test_data&jsonp=jsonpCallback_129620\r\n\r\n```\r\n\r\n### License\r\nIt is licensed under the Apache License, Version 2.0 ([read](http://www.apache.org/licenses/LICENSE-2.0.html)).\r\n",
  "google": "UA-64341792-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}