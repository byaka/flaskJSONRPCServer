{"name":"flaskJSONRPCServer","tagline":"A Python JSON-RPC over HTTP with flask and gevent","body":"[![PyPI version](https://img.shields.io/pypi/v/flaskJSONRPCServer.png)](https://pypi.python.org/pypi/flaskJSONRPCServer)\r\n[![PyPI downloads](https://img.shields.io/pypi/dm/flaskJSONRPCServer.png)](https://pypi.python.org/pypi/flaskJSONRPCServer)\r\n[![License](https://img.shields.io/pypi/l/flaskJSONRPCServer.svg)](http://www.apache.org/licenses/LICENSE-2.0.html)\r\n\r\n# flaskJSONRPCServer\r\nThis library is an implementation of the JSON-RPC specification. It supports only 2.0 specification for now, which includes batch submission, keyword arguments, etc.\r\n\r\n## Comments, bug reports\r\nflaskJSONRPCServer resides on **github**. You can file issues or pull requests [there](https://github.com/byaka/flaskJSONRPCServer/issues).\r\n\r\n## Requirements\r\n - Python >=2.6\r\n - Flask >= 0.10 (not tested with older version)\r\n - Gevent >= 1.0 (optionally)\r\n\r\n## Pros\r\n\r\n - Lib tested over **highload** (>=60 connections per second, 24/7 and it's not simulation) with **Gevent** enabled and no stability issues or memory leak (this is why i'm wrote this library)\r\n - Auto **CORS**\r\n - Simple switching to **Gevent** as backend\r\n - Auto fallback to **JSONP** on GET requests (for old browsers, that don't support CORS like **IE**<10)\r\n - Dispatchers can simply get info about connection (**IP**, **Cookies**, **Headers**)\r\n - Dispatchers can simply set **Cookies**, change output **Headers**, change output format for **JSONP** requests\r\n - Lib can be simply integreted with another **Flask** app on the same IP:PORT\r\n\r\n## Cons\r\n - No **documentation**, only examples below (sorry, i not have time for now)\r\n - Lib not handle **Notification** requests fully (for now client waiting, while server processes requests)\r\n - Lib not has **decorators**, so it not a \"Flask-way\" (this can be simply added, but i not use decorators, sorry)\r\n\r\n## Install\r\n```pip install flaskJSONRPCServer```\r\n\r\n## Examples\r\nSimple server\r\n```python\r\nimport sys, time, random\r\nsys.path.append('/var/python/libs/')\r\nsys.path.append('/var/python/')\r\nsys.path.append('/home/python/libs/')\r\nsys.path.append('/home/python/')\r\n\r\nfrom flaskJSONRPCServer import flaskJSONRPCServer\r\n\r\nclass mySharedMethods:\r\n   def random(self, mult=65536):\r\n      # Sipmly return random value (0..mult)\r\n      return int(random.random()*mult)\r\n\r\ndef echo(data='Hello world!'):\r\n   # Simply echo\r\n   return data\r\n\r\ndef myip(_connection=None):\r\n   # Return client's IP\r\n   return 'Hello, %s!'%(_connection.ip)\r\n\r\ndef setcookie(_connection=None):\r\n   # Set cookie to client\r\n   _connection.cookiesOut.append({'name':'myTestCookie', 'value':'Your IP is %s'%_connection.ip})\r\n   return 'Setted'\r\n\r\ndef block():\r\n   # Test for notification request. When it fully implemented, client must  not wait for compliting this function\r\n   time.sleep(10)\r\n   return 'ok'\r\n\r\ndef stats(_connection=None):\r\n   #calculate connections per second\r\n   tArr1={'connPerSec_now':_connection.server.connPerMinute.count/60.0, 'connPerSec_old':_connection.server.connPerMinute.oldCount/60.0, 'speedStats':{}}\r\n   #calculate spped stats\r\n   for k, v in _connection.server.speedStats.items():\r\n      tArr1['speedStats'][k+'_min']=min(v)\r\n      tArr1['speedStats'][k+'_max']=max(v)\r\n      tArr1['speedStats'][k+'_average']=sum(v)/float(len(v))\r\n   return tArr1\r\n\r\ndef big(_connection=None):\r\n   _connection.allowCompress=True #allow compression for this method\r\n   s=\"\"\"\r\nThey say that if you sat an infinite number of monkeys with an infinite number of typewriters, then they would write the complete works of Shakespeare. This is known as the Infinite Monkey Theorem. I always feel it would be nice to try the actual experiment out. I mean all these monkeys with typewriters would be kinda cool.\r\n\r\nHowever wouldn't it be easier to get one monkey and one typewriter and give him an infinite amount of time to see how he goes?\r\n\r\nAlthough in theory it sounds simpler, getting hold of even a single monkey is not that easy.\r\n\r\nBut what if we created a simulated monkey in Python? Now we are talking! That would be easy, and unlike a real monkey our simulated one could work all day and all night. No food required.\r\n\r\nSounds like a plan for a blog post.\r\n\r\nHowever I want to give our virtual monkey a chance. If he managed to type the complete works of Shakespeare without worrying about punctuation, we would be happy right? Same goes for capital letters, let's just ignore them for now. We want to give him a fighting chance of completing his task.\r\n\r\nTo help you get started I have taken a text file of the complete works of Shakespeare, and removed all punctuation and made all letters small. If any of you are thinking I did that by hand, think again. Python is your friend for automating tasks like that.\r\n\r\nBecause the complete works is a large tome, I have also included a similar file, with just Hamlet. You can choose which one you want your monkey to attempt!\r\n\r\nAs with all my blog posts I will give you the complete program first of all. Have a read through this and see how much of it you understand. Try and figure out those sections you donâ€™t. I will then go through the program a line at a time explaining it in more detail.\r\nWe do this by using scriptRead.count(monkeyTyped) >= 1 What does that even mean? Well we take the complete works of Shakespeare stored in scriptRead, and we do a count of how many times the thing in the brackets appears. If we put monkeyTyped into the brackets then it will count how many times monkeyCount appeared in scriptRead. We only need it to appear once but if it appears more than once, then that is ok as well. We check this with the greater than or equal to symbol >=.\r\n\r\nBut the line also has monkeyTyped = ''. Why is that? Well when we start off this while loop the monkey has not typed anything, as we have set the variable to = '' , which means an empty string. This would mean our while loop would be false straight away, and our monkey would never start typing.\r\n\r\nTo get around this we us an or condition. We check that monkeyTyped is '' or scriptRead.count(monkeyTyped) >= 1\r\n\r\nThe next line is the line which does the actual typing.\r\nWe take monkeyTyped and we add the result of (random.choice(string.ascii_lowercase + ' ')) onto it and save the result as monkeyTyped.\r\n\r\nWhat on earth is (random.choice(string.ascii_lowercase + ' ')) ?\r\n\r\nWell we want to simulate the monkey typing on a keyboard. We have already said to make it easy we will not ask for punctuation, although we should ask him for a space between words. Thats not too much to ask is it? We also said we will not be too concerned about it being in capital letters.\r\n\r\nSo random.choice picks something from inside the brackets by random selection. So what have we put in the brackets. The first thing is\r\n\r\nstring.ascii_lowercase\r\n\r\nThis creates a string of the lower case ascii letters. i.e\r\n\r\nabcdefghijklmnopqrstuvwxyz\r\n\r\nWe also add onto the end of that a space using ' '\r\n\r\nNow remember this has a space between the two speech-marks. This is different from when we are creating a blank string, which doesn't have a space.\r\n\r\nOnce he has typed a word, the loop will start again and check if what has been typed is in the complete works. If it is he will continue. If not he will go to the else statement.\r\nHere we return what he has typed. However remember we only get to this place if what is typed is not in the complete works. That's no use to us! We will need to remove the last letter of what he typed, as it was that last letter we know to have made perfect Shakespeare prose into gibberish.\r\n\r\nSo we return monkeyTyped[:-1] which returns everything up to the last letter but not the last letter.\r\n\r\nOk back to where we were in the main program.\r\n\r\nRemember we said we would keep track of the number of key presses? Well lets update that now. We know the monkey has just typed a word, so it is easy to determine the size of that word and increase keyPresses by that amount. Oh but the monkey typed a letter which turned his prose into gibberish. We should add that on as well as we want our count to be accurate!\r\nThis line checks to see if the number of key presses he has made is a multiple of 10,000. The % checks if keyPresses / 10,000 has no remainder i.e. it is a multiple of 10,000. If it is then it will print the number of key-presses made. This only works if the key-presses are an exact multiple of 10,000. There will be times when the monkey is in the middle of a word when this happen, so it will not report back. However it reports enough to make you realise the monkey is still working and not fallen asleep.\r\n\r\nRemember to press F5 to save and run your program.\r\n\r\nThat is the end of the program. All you need now it to download the complete works of Shakespeare or just Hamlet if thats what you want to use. Use the links below to do that.\r\n   \"\"\"\r\n   return s\r\n\r\nif __name__=='__main__':\r\n   print 'Running api..'\r\n   # Creating instance of server\r\n   #    <blocking>      set is this server async\r\n   #    <cors>          switch auto CORS support\r\n   #    <gevent>        switch to using Gevent as backend\r\n   #    <debug>         switch to logging connection's info from Flask\r\n   #    <log>           switch to logging debug info from flaskJSONRPCServer\r\n   #    <fallback>      switch auto fallback to JSONP on GET requests\r\n   #    <allowCompress> switch auto compression\r\n   server=flaskJSONRPCServer((\"0.0.0.0\", 7001), blocking=False, cors=True, gevent=False, debug=False, log=True, fallback=True, allowCompress=False)\r\n   # Register dispatcher for all methods of instance\r\n   server.registerInstance(mySharedMethods(), path='/api')\r\n   # Register dispatchers for single functions\r\n   server.registerFunction(setcookie, path='/api')\r\n   server.registerFunction(echo, path='/api')\r\n   server.registerFunction(block, path='/api')\r\n   server.registerFunction(myip, path='/api')\r\n   big._alias='bigdata' #setting alias for method\r\n   server.registerFunction(big, path='/api')\r\n   server.registerFunction(stats, path='/api')\r\n   # Run server\r\n   server.serveForever()\r\n   # Now you can access this api by path http://127.0.0.1:7001/api for JSON-RPC requests\r\n   # Or by path http://127.0.0.1:7001/api/<method>?jsonp=<callback>&(params) for JSONP requests\r\n   #    For example by http://127.0.0.1:7001/api/echo?data=test_data&jsonp=jsonpCallback_129620\r\n\r\n```\r\n\r\n## License\r\nIt is licensed under the Apache License, Version 2.0 ([read](http://www.apache.org/licenses/LICENSE-2.0.html)).\r\n","google":"UA-64341792-1","note":"Don't delete this file! It's used internally to help with page regeneration."}